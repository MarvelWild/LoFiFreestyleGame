	
	в идеале все симуляции - отдельный поток
	entity_update to clients
		on slow update
	server simulation
tree growth

animate
	сразу понятно что надо и где не реализовано! (закрывать все ходы сразу)
	лог возможно будет крутой
эксперимент: лог дривен девелопмент




		

существа бегут на свой остров
африка
	пустыня
		змеи да верблюды
австралия
разные острова
приручить слона бананом
	should not be remote because it was picked up from server again
client crash on place-pickup-place cauldron
+seeds sholdnt be in world when in action bar, but they added to collision
client cannot pickup placed cauldron		
		cauldron ok, but bucket not placed on client
	test server-client
	+server only
drop pot,pickup,drop again- disappeared
houses
zombie
e-man
fly dragon
random start screen creatures


food
wolf
stamina
water
привязать маунта
canvas, entity controls update
debugger entity count
ai control for player 
ai control for horse
ride horse pnly
any ai as mount
any creature as mount
easy creature add (put sprite into folder)
		


		send event to all except self
	entity updated event
skin change: networking
			+old:receive world update
			+old:receive inventory update
		+receive pickup_ok
		+send event (see)
			+respond with picked event to everyone on success
		+implement event.isServerOnly
	+implement Player.pickup
			+define pickable: isInWorld is ok for now
		+filter pickable
		+grab collisions
	+space key (no selection required)
		
			+item disappeared, not appeared in inventory
		+server place, client join and pick

+debugger: dump feature


+seed in world (collision), should not. спутал семена с игроками
	+seed was added to collision, now adding only world entity
		
		

			+хотя у нас клиент авторитарен, пикапом он полностью забирает вещь себе
		+после пикапа должен происходить трансфер: шлём всем трансфер, а поднимающему - ок
	+сервер бросает котёл, клиент поднимает, ложит, не может поднять второй раз
		+check fix
		+trace log(all channels)
	+server put item, client picks, puts, picks again - item duplicated in world and inv
	+allow 5th item
+item pickup more net tests

		+test log channels
	+separate log for networking data
+less log spam
separate logs for each client on server
+ai: stay in bounds
	+not reprod, ok for now
+bug: server placed cauldron, client crash
		+isInWorld=false
	+read logs
	+reproduce on clean game
+bug: server placed cauldron, nothing on client
optional network compression
conditional code
flight
mount: networking
		+Entity.getWorld should give pantera
	+pantera try move, but wasnt transferred to client
+client crash
+pickup player bug
+cam: look at player mid, not corner
	
+login via cmd line
		
	ai move
	+place item
	+move
	+c2 sees no c1
		+no c2 on c1. join should broadcast
	+c1 crash on c2 (join/move)
		+include login into save dir
	+c2 no player
+2 clients test
+girl collision lookup crash


		+dont req at acceptAtServer if login match
	+first reg at create, second at acceptAtServer
		+save validation to catch this (or container validation on add)
	+double same bucket in save
+bug double bucket registered
+	not world entities not included in collision
+bug: inventory items are selectable
+bug: cauldron not selectable (collision box not moved on play)


	+separate tiles for faster lookup
			try draw all tiles to canvas, too much draw calls - later
			
			+add profiler
		+take profiling snapshot
	+optimize at large scale
+scaling


					+add login to event
				+client should send event with target=all
				+read log
				+add event processing to log
			+client moves server player
					+oneLine for console only, full formatting for file
					+better logs (send cmd, reqid)
				+collect logs
						+trace client
					+client should not send back not own 'all' events
				+collect more logs
			+server move moves client too (only on server)
		+live
		+synthetic tests? nah, real world only
		'server' event: pickup
		+'all' event: move
	+tests
	+make refactor
+event system refactor: add event.target

+update collision system on player move
try lovebird lib
ride together (mount anything: other player, ai pantera)
	color picker
anything can change color
dragon shoot fire and burns everything
fly
collectable flowers
plantable flower seeds
венки
+play as dragon
+actiobar slot 4 becomes 3
+client crash on using sapling	
	faster speed
	+x button: mount/unmount
	+stick to player
	+img
+horse

	+draw once
	+selected ui
		
				+"with size"
			+define that object: greass,bottle,any entity with size.
				
			+player has empty h,w
		+register selectable objects / all collidable
		
					+seems fine for now
				+as post-collision filter?
				+as hc instances? no (intersection?)
			+groups?
					con: may require multiple requests per frame for precise calc
				alternative: update entire system on request?
			notify collision system on movement/sprite swap (x,y,w,h change)
		+learn hc lib
	+objects by coord
	+react to click
+object select by shift click


	+bucket
	+при нахождении котла в инвентаре - не рисовать его в мире
	+cauldron
witchery
	
		+components can subscribe to keys
	+keys 1-2 to switch fav
	+highlight active favorite
	+put in 2nd slot
	+describe
+birch sapling

	настройка быстрый аи
	+			трансфернутые на клиенте помечать aiEnabled=false
	+		приходит через трансфер
	+		цепляется в activate
	+	на клиенте не должен происходить pantera|*.updateAi
	+пантеру создали на сервере, клиент свалился
+ai: events system


single id, аля gamemaker позже подумать, на новом проекте можно потестить
клиент не загружает мир
logout
client/events autoload

gm mode: enter any entity | invisibility | free roam (drone mode)


	

	+нет: иизменение свойства aiEnabled не исключило сущность из аишных на клиенте
	+теперь включился, но на клиенте остались дотрансферные пантеры
			+получение прототипа
		+взять из прототипа
	+при переходе на сервер аи не включился
+проверить пантеру с клиента	
+стартовая пантера пришла с аи:
+пантера не появилась на клиенте
	
+trace seed.use on server: как он идёт на клиента?


Процесс использования семян:
	выбран вариант 1 : умный клиент
		клиент создаёт их у себя, делает трансфер сущности
		сервер после трансфера уведомляет клиенты о добавившейся сущности
		клиент заменяет трансфернутую у себя
		
		плюсы: мгновенный респонз на клиенте
		минусы: 
			до трансфера если сущность куда то уйдёт - после трансфера референсы станут неактуальны
			до трансфера взаимодействовать с сущностью - неопределённость, нужно помечать сущность как нестабильную
			
		
	вариант 2 : умный сервер
		клиент отправляет команду
		сервер создаёт
			плюсы:
			минусы:
				клиент ждёт результата



возможность заслать ответ всем, а запросившему-также передать requestId
possibility to detect changed entities (for networking)
		по этой модели теряется авторитативность клиента в своих действиях, стоило бы оставить - например 
			+клиент создаёт сущность, 
			+и выполняет ивент помещения сущности на сервер, 
			+и передачу серверу её
	+response is new entity
	+seed use creates plant on server
+event response could be different from processing event


grass from client should be saved on server
	register player items on join
		check creation code
	seed not found
	
	+use on client, send entity create event
+item use: network
	ui for that / chat is ok
emotes: dance, jump,anything
	
		and loads+
	but saves self+
client does not save world+

			для этого сервер у трансфернутых отдаёт oldId
			если его - разрегистрирует прежние
			если не его логин - просто регистрирует их
		+клиент отвечает на entities_transferred
				с такими не взаимодействуем/или с ожиданием трансфера
			пометить isTransferring+
		+transfer_to_server созданную сущность
	+клиент сеет семя

динамическое создание объектов с помощъю импорта или рисования в игре


	+сохраняются в 1 и ту же папку, разделить
+на сервере наблюдается 2 одинаковых игрока:
				
				
		+ServerEntity.tcpServer:send(packed..NET_MSG_SEPARATOR, clientId)
	+sendEventsToClients implement, сейчас по этой причине клиент получает свои же.
+client events echo		
+логин привязывать к clientId	

			+player still have no login on serv - old save
			+inherit all remote entities from base
		+player.login was nil from server
	+клиент их принимает (events_client)
+сервер шлёт ивенты на клиентов
			+привязка к клиенту (login у сущности)
		+понимание ремот сущностей
		
		
			+хранить логин источника в каждой сущности: в событии
		+события
	+и применяет
	+сервер их принимает, 
+клиент шлёт свои команды (Event) на сервер	
			+определяет по ид
		+сервер не сохраняет удалённых клиентов
	клиент отправляет себя на сервер+
	
	
	+клиент получает мир из сервера
+загрузить состояние мира с сервера
+клиент не активирует аи



+клиент не создаёт мир, только себя (клиентская анархия ради мягкого экспериенса, мы ведь все равно песочница) позже
+сервер сеет семя
клиент запускается без загрузки+


	+затем просто включиться в цикл команд, например помнить фрейм снапшота, и с него запрашивать. а лучше - сервер
		+сам начинает слать с момента первого снапа

			как single response handler+
		получить ок+
		послать логин+
	в состоянии клиента не включать аи, объекты запросить с сервера
	clients all authoritative
		c mode
	client connect
	+client is server (server mode)
server/client
	
	setAnimation - можно ф draw менять тут
animation - later


rotate image left when walking left later
object origin: bottom left by default
	animate pantera walk later
animation
+fun: change player skin to any pic (home)




profiler
		mixed!
	architecture: generic or specific?
	
	
	+pet ai: follow player
+sheep
	
	+client mode
	+server mode
+multiplayer!
					
					
					no customizable editor item? [solved: hybrid items, auto+custom]
				con:
				pro:easy auto items
			new(isProto?) - way to create entity without id and registering?
			register all possible somewhere
		entity prototypes for editor - mb later, or never, just build them for now
		
		
		

		+editor: draw proto entity manually
	+editor items should not be saved, and even registered
			+went off with new save
			+log draw calls
		+bug: inactive entity still draws
	+editor entities should not run ai or updates
	+closing hides active
	+displays current item under cursor
	+opens/closes by f11
	+rmb places item
	
		way for entity to listen for keys better way
		+way for entity to listen for keys-later, use hack
	+scroll items
	
+creative mode editor: place any item


carrots

+ai update: future commands queue instead of update()	
				proto image
				then show available actions on right bar (todo)
			rclick select object (cycle if many)
				con: multiple objects
			rclick?
		ability to start dialog, by...
	talk to npc (dialog system proto)
quests and npc!
combat?
fire
areas (generic)
adventures
heat/cold
fishing?
mating?
animations?
swimming
flowers..
trees from seeds..
editor: ability to place any entity
more content?
hunger games?
what next?

		profile
		faster sprites
		less off-screen activity
	opt plan: 
performance: 350 panteras at 15 fps (0 optimizations yet)		
+ai some randomness
		+make move command, like for player
			+test
		+updateable entities
		+call it
	+slow update func "updateAi" - every x frames for now
	ai architecture
+pantera ai : walk around randomly

	+saving
	+spawn from seed for now
+panteras )
+what next?



+save grass(world entities)


+rmb: plant seed
+randomness of seeds


problem: entities are data-only (serialization). Need a way to fast sprites. (see Entity._drawable, assign sprite once somewhere)

sprite lookup optimization.

knowledge system (ability to id game objects)
y sort
+player not drawn


	
	+draw favorites
+give stack of random seeds into fav slot 1

+deactivate debugger
	
	+scale 4x
+recover action bar
+recover ingame debugger
	+no, do 1 calc in move command
	+con: slower
	+pro: convenient
+draw from bottom? (gamey=entY+h)
+draw player (all entities)
+make runnable
	+player sprite after load
+Save/Load
+move world/


+Refactor: easier architecture:
+	data(only! easy serializable) entities maintained by Entity module
+	%entity% contains all code, new() and the rest. keep new() at top
	
	






































+убрать isBuilt
	
	сохранение саб сущностей
			or split func and data?
				
					try dump()
				deaerialize crash
			+disable func serialization
		+try https://github.com/pkulchenko/serpent (later)
	+alt: advanced serializer?
		pro: resolves cross-entity reference
	use entity.pack/unpack to handle references?
+activeFavorite: save as reference	
	+save formatted
+bug: player: no sprite after load (new game is ok)

	
	growth process
	
			react to click
		right click=default action with active slot
	+plant action
			+highlight in action bar
			+test
		+define active item
		+draw count (seeds.stackCount)
		+draw favorites on toolbar
			+"new" command line parameter to force new game
		+test
		+describe entity
	+give player mixed seeds
+i want to plant some grass and flowers



+механизм пост-десериал инициализации
+дебаггер старт деактивир
+дебаггер деактивировать
дебаггер - объявить ui+
+entity=component
+затайлить

	в слот belt-1
	+дать семя
	убрать картинки
	как компонент
	отрисовка
+ui 
	рандомный объект по рклик
заселить 
+world tiling (tiled mb)

	register as entity+
rmb target select object
	если несколько - действие с объектом по умолчанию, во
	если коллизия одна - действия с объектом
спрайты пересеклись - коллизия
	
		+entities
	+bounds

player origin legs+
		stop prev
	make command
	unscale+
	read coord+
+mouse walking
scale+
lowres+
download tutorials


-- low

+для компонентов не выдавать ид